<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on Nu_1</title><link>https://dumindu.github.io/nu_1/blog/</link><description>Recent content in Blogs on Nu_1</description><generator>Hugo</generator><language>en-US</language><lastBuildDate>Thu, 11 Dec 2025 01:40:31 +0800</lastBuildDate><atom:link href="https://dumindu.github.io/nu_1/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Concurrency Patterns in Golang</title><link>https://dumindu.github.io/nu_1/blog/concurrency-patterns-in-golang/</link><pubDate>Wed, 26 Nov 2025 00:00:00 +0800</pubDate><guid>https://dumindu.github.io/nu_1/blog/concurrency-patterns-in-golang/</guid><description>&lt;h2 id="essentials"&gt;Essentials&lt;/h2&gt;
&lt;h3 id="1-os-threads-vs-goroutines"&gt;1. OS Threads Vs Goroutines&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OS Threads: Managed by the kernel, fixed stack size 1MB (But Modern Linux uses NPTL/ Native POSIX Thread Library, 256KB or less), context switching between OS threads requires a costly transition from user space to kernel space, forcing the operating system to interrupt its core work.&lt;/li&gt;
&lt;li&gt;Goroutines: Managed by the Go runtime scheduler in user space, ~2KB dynamic stack size, can multiplex thousands of goroutines onto a very few OS threads, context switching is lightning-fast as it&amp;rsquo;s managed in user space. Concurrently executing functions.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-synchronization-patterns"&gt;2. Synchronization Patterns&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;General&lt;/p&gt;</description></item><item><title>The Next Wave!</title><link>https://dumindu.github.io/nu_1/blog/the-next-wave-of-programming/</link><pubDate>Sat, 26 Jul 2025 00:00:00 +0800</pubDate><guid>https://dumindu.github.io/nu_1/blog/the-next-wave-of-programming/</guid><description>&lt;p&gt;&lt;strong&gt;Programming Becoming More Abstracted&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Today, the traditional gatekeeping of code is dissolving. Tools like Claude Code, Gemini CLI, OpenAI Codex, Bubble, and Manus are enabling managers, designers, and other non-devs to translate vague specs into functional prototypes — or even deployable applications.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;What used to take teams of developers now sometimes takes a few clever prompts and a drag-and-drop interface. It feels like magic. But it comes with a cost!&lt;/em&gt;&lt;/p&gt;</description></item><item><title>Data Structures</title><link>https://dumindu.github.io/nu_1/blog/data-structures/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0800</pubDate><guid>https://dumindu.github.io/nu_1/blog/data-structures/</guid><description>&lt;h2 id="definition"&gt;Definition&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;⭐️ Data Structures is &lt;strong&gt;a way of organizing and storing data efficiently.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;They define:
&lt;ul&gt;
&lt;li&gt;the &lt;strong&gt;relationship between the data&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;the &lt;strong&gt;operations that can be performed on the data&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So that they can be accessed and worked with efficiently.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="arrays"&gt;Arrays&lt;/h2&gt;
&lt;p&gt;An array stores a collection of items at adjoining memory locations. Items can be accessed using their indices.&lt;/p&gt;
&lt;p&gt;Because of their ability to use an index to directly access an element, arrays are often used when the size of the collection can be known in advance. They are frequently used in mathematical computations where accessing elements in a sequential manner is common. For instance, matrices, which are two-dimensional arrays, are often used in graphics transformations.&lt;/p&gt;</description></item></channel></rss>